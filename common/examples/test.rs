use common::model::{
    funcs::gen_child_states_dr,
    game::{Game, GameMove},
    piece::Bag,
};

fn main() {
    let moves = vec![
        GameMove::Hold,
        GameMove::ShiftLeft,
        GameMove::ShiftLeft,
        GameMove::ShiftLeft,
        GameMove::ShiftLeft,
        GameMove::HardDrop,
        GameMove::Hold,
        GameMove::RotateRight,
        GameMove::ShiftRight,
        GameMove::HardDrop,
        GameMove::HardDrop,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::HardDrop,
        GameMove::HardDrop,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::HardDrop,
        GameMove::Hold,
        GameMove::HardDrop,
        GameMove::Hold,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::HardDrop,
        GameMove::Hold,
        GameMove::RotateRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::HardDrop,
        GameMove::RotateLeft,
        GameMove::ShiftLeft,
        GameMove::HardDrop,
        GameMove::RotateRight,
        GameMove::ShiftLeft,
        GameMove::ShiftLeft,
        GameMove::ShiftLeft,
        GameMove::ShiftLeft,
        GameMove::HardDrop,
        GameMove::RotateRight,
        GameMove::HardDrop,
        GameMove::RotateRight,
        GameMove::ShiftRight,
        GameMove::ShiftRight,
        GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::RotateRight,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::SoftDrop,
        // GameMove::RotateLeft,
        // GameMove::RotateLeft,
        // GameMove::SoftDrop,
        // GameMove::RotateLeft,
        // GameMove::HardDrop,
        // GameMove::RotateRight,
        // GameMove::HardDrop,
        // GameMove::RotateRight,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::SoftDrop,
        // GameMove::RotateLeft,
        // GameMove::RotateLeft,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::RotateLeft,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::RotateRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::RotateRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::RotateRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::SoftDrop,
        // GameMove::RotateRight,
        // GameMove::HardDrop,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::RotateRight,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::SoftDrop,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::RotateLeft,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::RotateRight,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::HardDrop,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::RotateLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::SoftDrop,
        // GameMove::RotateLeft,
        // GameMove::HardDrop,
        // GameMove::RotateLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::HardDrop,
        // GameMove::RotateLeft,
        // GameMove::ShiftRight,
        // GameMove::SoftDrop,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::RotateRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::ShiftRight,
        // GameMove::HardDrop,
        // GameMove::ShiftLeft,
        // GameMove::SoftDrop,
        // GameMove::HardDrop,
        // GameMove::RotateRight,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::SoftDrop,
        // GameMove::RotateLeft,
        // GameMove::HardDrop,
        // GameMove::Hold,
        // GameMove::Rotate180,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::ShiftLeft,
        // GameMove::HardDrop,
    ];
    let mut game = Game::new_with_bag(&Bag::new());
    for game_move in moves.iter() {
        game.make_move(*game_move);
        if game.queue_pieces.len() < 7 {
            game.extend_bag(&Bag::new());
        }
    }
    println!("{}", game);
    let child_states = gen_child_states_dr(&game);
    // sketchy lexicographical sort
    let mut pivot = child_states
        .into_iter()
        .map(|x| {
            let lex = x.1.into_iter().map(|x| x.to_string()).collect::<Vec<_>>();
            (x.0, x.1, lex)
        })
        .collect::<Vec<_>>();
    pivot.sort_by(|a, b| a.2.cmp(&b.2));
    let child_states = pivot.into_iter().map(|x| (x.0, x.1)).collect::<Vec<_>>();
    for (child_state, game_moves) in child_states {
        println!("{}\n{:?}\n", child_state, game_moves)
    }
}
